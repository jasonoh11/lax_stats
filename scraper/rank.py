import numpy as np

def calculate_rank(games, ids):

	num_teams = len(ids)

	adj_matrix = np.zeros((num_teams, num_teams))

	for (_, team1, team2, score1, score2, division, league_id) in games:
		loser = team1 if score1 < score2 else team2
		winner = team1 if score1 > score2 else team2
		margin = abs(score1 - score2)

		if team1 in ids and team2 in ids:
			# Compress the reward for blowouts
			adj_matrix[ids[loser], ids[winner]] += np.sqrt(margin)


	# Normalize each row - handle undefeated teams by distributing equally across all columns
	for row in adj_matrix:
		row_sum = row.sum()
		for i, n in enumerate(row):
			row[i] = (1 / num_teams) if row_sum == 0 else (n / row_sum)

	# Apply a damping fator of 0.15
	uniform_matrix = np.ones((num_teams, num_teams)) / num_teams
	markov_matrix = (0.85) * adj_matrix + (0.15) * uniform_matrix
	

	eigenvalues, eigenvectors = np.linalg.eig(markov_matrix.T)
	principal_eigenvector = eigenvectors[:, np.isclose(eigenvalues, 1)].flatten()
	principal_eigenvector = principal_eigenvector / np.sum(principal_eigenvector)
	ranking_vector = np.real(principal_eigenvector)	


	'''
	The following scaling code is partially generated by GPT-4o to help 
	produce intuitive, accurate rating values
	'''

	# 1. Apply a logarithmic transformation to reduce right skew.
	epsilon = 1e-8
	log_ratings = np.log(ranking_vector + epsilon)

	# 2. Convert to z-scores (this centers the data and preserves league variance).
	mean_log = np.mean(log_ratings)
	std_log = np.std(log_ratings)
	z_scores = (log_ratings - mean_log) / std_log

	# 3. Apply logistic (sigmoid) scaling with a lower steepness (k).
	A = 100   # Maximum rating
	k = 1.0   # Lower steepness reduces saturation at the top.
	# We want an average team (z = 0) to be around 60.
	x0 = -0.405465 / k  # x0 is derived so that when z=0, rating â‰ˆ 60.

	scaled_ratings = A / (1 + np.exp(-k * (z_scores - x0)))


	team_ratings = {}
	for (team, id) in ids.items():
		rating = float(scaled_ratings[id].item())
		team_ratings[team] = rating

	return team_ratings


def calculate_schedule(team_ratings, games):

	# init map to store team -> (games played, aggregate rating of opponenets)
	aggregate_opp_rating = {}

	# for each game, get the rating of each team
	
	for (_, team1, team2, score1, score2, division, league_id) in games:
		if team1 in team_ratings and team2 in team_ratings:
			team1_rating = team_ratings[team1]
			team2_rating = team_ratings[team2]

			if team1 in aggregate_opp_rating:
				entry = list(aggregate_opp_rating[team1])
				entry[0] += 1
				entry[1] += team2_rating
				aggregate_opp_rating[team1] = tuple(entry)
			else:
				aggregate_opp_rating[team1] = (1, team2_rating)

			if team2 in aggregate_opp_rating:
				entry = list(aggregate_opp_rating[team2])
				entry[0] += 1
				entry[1] += team1_rating
				aggregate_opp_rating[team2] = tuple(entry)
			else:
				aggregate_opp_rating[team2] = (1, team1_rating)

	schedule_ratings = {} # team -> average opponent rating
	for (team, (games_played, opp_rating)) in aggregate_opp_rating.items():
		avg_opp_rating = opp_rating / games_played
		schedule_ratings[team] = avg_opp_rating

	return schedule_ratings
	
